"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SeriesStringFunctions = void 0;
const _1 = require(".");
const utils_1 = require("../utils");
const functions_1 = require("../lazy/functions");
const SeriesStringFunctions = (_s) => {
    const wrap = (method, ...args) => {
        const ret = _s[method](...args);
        return (0, _1._Series)(ret);
    };
    const handleDecode = (encoding, strict) => {
        switch (encoding) {
            case "hex":
                return wrap("strHexDecode", strict);
            case "base64":
                return wrap("strBase64Decode", strict);
            default:
                throw new RangeError("supported encodings are 'hex' and 'base64'");
        }
    };
    return {
        concat(delimiter) {
            return (0, _1._Series)(_s)
                .toFrame()
                .select((0, functions_1.col)(_s.name).str.concat(delimiter).as(_s.name))
                .getColumn(_s.name);
        },
        contains(pat) {
            return wrap("strContains", (0, utils_1.regexToString)(pat), false);
        },
        decode(arg, strict = false) {
            if (typeof arg === "string") {
                return handleDecode(arg, strict);
            }
            return handleDecode(arg.encoding, arg.strict);
        },
        encode(encoding) {
            switch (encoding) {
                case "hex":
                    return wrap("strHexEncode");
                case "base64":
                    return wrap("strBase64Encode");
                default:
                    throw new RangeError("supported encodings are 'hex' and 'base64'");
            }
        },
        extract(pat, groupIndex) {
            return wrap("strExtract", (0, utils_1.regexToString)(pat), groupIndex);
        },
        jsonExtract(dtype, inferSchemaLength) {
            return wrap("strJsonExtract", dtype, inferSchemaLength);
        },
        jsonPathMatch(pat) {
            return wrap("strJsonPathMatch", pat);
        },
        lengths() {
            return wrap("strLengths");
        },
        lstrip() {
            return wrap("strReplace", /^\s*/.source, "");
        },
        padStart(length, fillChar) {
            return wrap("strPadStart", length, fillChar);
        },
        zFill(length) {
            return wrap("strZFill", length);
        },
        padEnd(length, fillChar) {
            return wrap("strPadEnd", length, fillChar);
        },
        replace(pat, val) {
            return wrap("strReplace", (0, utils_1.regexToString)(pat), val);
        },
        replaceAll(pat, val) {
            return wrap("strReplaceAll", (0, utils_1.regexToString)(pat), val);
        },
        rstrip() {
            return wrap("strReplace", /[ \t]+$/.source, "");
        },
        slice(start, length) {
            return wrap("strSlice", start, length);
        },
        split(by, options) {
            const inclusive = typeof options === "boolean" ? options : options?.inclusive;
            const s = (0, _1._Series)(_s);
            return s
                .toFrame()
                .select((0, functions_1.col)(s.name).str.split(by, inclusive).as(s.name))
                .getColumn(s.name);
        },
        strip() {
            const s = (0, _1._Series)(_s);
            return s
                .toFrame()
                .select((0, functions_1.col)(s.name).str.strip().as(s.name))
                .getColumn(s.name);
        },
        strptime(dtype, fmt) {
            const s = (0, _1._Series)(_s);
            return s
                .toFrame()
                .select((0, functions_1.col)(s.name).str.strptime(dtype, fmt).as(s.name))
                .getColumn(s.name);
        },
        toLowerCase() {
            return wrap("strToLowercase");
        },
        toUpperCase() {
            return wrap("strToUppercase");
        },
    };
};
exports.SeriesStringFunctions = SeriesStringFunctions;
