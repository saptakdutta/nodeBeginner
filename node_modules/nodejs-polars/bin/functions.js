"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.concat = exports.repeat = void 0;
/* eslint-disable no-redeclare */
const construction_1 = require("./internals/construction");
const series_1 = require("./series");
const dataframe_1 = require("./dataframe");
const polars_internal_1 = __importDefault(require("./internals/polars_internal"));
const utils_1 = require("./utils");
/**
 * _Repeat a single value n times and collect into a Series._
 * @param value - Value to repeat.
 * @param n - Number of repeats
 * @param name - Optional name of the Series
 * @example
 *
 * ```
 *
 * >  const s = pl.repeat("a", 5)
 * >  s.toArray()
 * ["a", "a", "a", "a", "a"]
 *
 * ```
 */
function repeat(value, n, name = "") {
    const dtype = (0, construction_1.jsTypeToPolarsType)(value);
    const s = polars_internal_1.default.JsSeries.repeat(name, value, n, dtype);
    return (0, series_1._Series)(s);
}
exports.repeat = repeat;
function concat(items, options = { rechunk: true, how: "vertical" }) {
    const { rechunk, how } = options;
    if (!items.length) {
        throw new RangeError("cannot concat empty list");
    }
    if ((0, utils_1.isDataFrameArray)(items)) {
        let df;
        switch (how) {
            case "vertical":
                df = items.reduce((acc, curr) => acc.vstack(curr));
                break;
            case "horizontal":
                df = (0, dataframe_1._DataFrame)(polars_internal_1.default.horizontalConcat(items.map((i) => i.inner())));
                break;
            case "diagonal":
                df = (0, dataframe_1._DataFrame)(polars_internal_1.default.diagonalConcat(items.map((i) => i.inner())));
                break;
            default:
                throw new TypeError("unknown concat how option");
        }
        return rechunk ? df.rechunk() : df;
    }
    if ((0, utils_1.isSeriesArray)(items)) {
        const s = items.reduce((acc, curr) => acc.concat(curr));
        return rechunk ? s.rechunk() : s;
    }
    throw new TypeError("can only concat series and dataframes");
}
exports.concat = concat;
