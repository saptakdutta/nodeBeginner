"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeUnit = exports.DataType = void 0;
const field_1 = require("./field");
class DataType {
    get variant() {
        return this.constructor.name.slice(1);
    }
    identity = "DataType";
    get inner() {
        return null;
    }
    equals(other) {
        return (this.variant === other.variant &&
            this.inner === null &&
            other.inner === null);
    }
    /** Null type */
    static get Null() {
        return new _Null();
    }
    /** `true` and `false`. */
    static get Bool() {
        return new _Bool();
    }
    /** An `i8` */
    static get Int8() {
        return new _Int8();
    }
    /** An `i16` */
    static get Int16() {
        return new _Int16();
    }
    /** An `i32` */
    static get Int32() {
        return new _Int32();
    }
    /** An `i64` */
    static get Int64() {
        return new _Int64();
    }
    /** An `u8` */
    static get UInt8() {
        return new _UInt8();
    }
    /** An `u16` */
    static get UInt16() {
        return new _UInt16();
    }
    /** An `u32` */
    static get UInt32() {
        return new _UInt32();
    }
    /** An `u64` */
    static get UInt64() {
        return new _UInt64();
    }
    /** A `f32` */
    static get Float32() {
        return new _Float32();
    }
    /** A `f64` */
    static get Float64() {
        return new _Float64();
    }
    static get Date() {
        return new _Date();
    }
    /** Time of day type */
    static get Time() {
        return new _Time();
    }
    /** Type for wrapping arbitrary JS objects */
    static get Object() {
        return new _Object();
    }
    /** A categorical encoding of a set of strings  */
    static get Categorical() {
        return new _Categorical();
    }
    static Datetime(timeUnit, timeZone = null) {
        return new _Datetime(timeUnit, timeZone);
    }
    /**
     * Nested list/array type
     *
     * @param inner The `DataType` of values within the list
     *
     */
    static List(inner) {
        return new _List(inner);
    }
    static Struct(fields) {
        return new _Struct(fields);
    }
    /** A variable-length UTF-8 encoded string whose offsets are represented as `i64`. */
    static get Utf8() {
        return new _Utf8();
    }
    toString() {
        if (this.inner) {
            return `${this.identity}(${this.variant}(${this.inner}))`;
        }
        else {
            return `${this.identity}(${this.variant})`;
        }
    }
    toJSON() {
        const inner = this.inner;
        if (inner) {
            return {
                [this.identity]: {
                    [this.variant]: inner[0],
                },
            };
        }
        else {
            return {
                [this.identity]: this.variant,
            };
        }
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.toJSON();
    }
    static from(obj) {
        return null;
    }
}
exports.DataType = DataType;
class _Null extends DataType {
}
class _Bool extends DataType {
}
class _Int8 extends DataType {
}
class _Int16 extends DataType {
}
class _Int32 extends DataType {
}
class _Int64 extends DataType {
}
class _UInt8 extends DataType {
}
class _UInt16 extends DataType {
}
class _UInt32 extends DataType {
}
class _UInt64 extends DataType {
}
class _Float32 extends DataType {
}
class _Float64 extends DataType {
}
class _Date extends DataType {
}
class _Time extends DataType {
}
class _Object extends DataType {
}
class _Utf8 extends DataType {
}
class _Categorical extends DataType {
}
/**
 * Datetime type
 */
class _Datetime extends DataType {
    timeUnit;
    timeZone;
    constructor(timeUnit, timeZone) {
        super();
        this.timeUnit = timeUnit;
        this.timeZone = timeZone;
    }
    get inner() {
        return [this.timeUnit, this.timeZone];
    }
    equals(other) {
        if (other.variant === this.variant) {
            return (this.timeUnit === other.timeUnit &&
                this.timeZone === other.timeZone);
        }
        else {
            return false;
        }
    }
}
class _List extends DataType {
    __inner;
    constructor(__inner) {
        super();
        this.__inner = __inner;
    }
    get inner() {
        return [this.__inner];
    }
    equals(other) {
        if (other.variant === this.variant) {
            return this.inner[0].equals(other.inner[0]);
        }
        else {
            return false;
        }
    }
}
class _Struct extends DataType {
    fields;
    constructor(inner) {
        super();
        if (Array.isArray(inner)) {
            this.fields = inner;
        }
        else {
            this.fields = Object.entries(inner).map(field_1.Field.from);
        }
    }
    get inner() {
        return this.fields;
    }
    equals(other) {
        if (other.variant === this.variant) {
            return this.inner
                .map((fld, idx) => {
                const otherfld = other.fields[idx];
                return otherfld.name === fld.name && otherfld.dtype.equals(fld.dtype);
            })
                .every((value) => value);
        }
        else {
            return false;
        }
    }
    toJSON() {
        return {
            [this.identity]: {
                [this.variant]: this.fields,
            },
        };
    }
}
/**
 * Datetime time unit
 */
var TimeUnit;
(function (TimeUnit) {
    TimeUnit["Nanoseconds"] = "ns";
    TimeUnit["Microseconds"] = "us";
    TimeUnit["Milliseconds"] = "ms";
})(TimeUnit || (exports.TimeUnit = TimeUnit = {}));
/**
 * @ignore
 * Timeunit namespace
 */
(function (TimeUnit) {
    function from(s) {
        return TimeUnit[s];
    }
    TimeUnit.from = from;
})(TimeUnit || (exports.TimeUnit = TimeUnit = {}));
/**
 * Datatype namespace
 */
(function (DataType) {
    /**
     * deserializes a datatype from the serde output of rust polars `DataType`
     * @param dtype dtype object
     */
    function deserialize(dtype) {
        if (typeof dtype === "string") {
            return DataType[dtype];
        }
        let { variant, inner } = dtype;
        if (variant === "Struct") {
            inner = [
                inner[0].map((fld) => field_1.Field.from(fld.name, deserialize(fld.dtype))),
            ];
        }
        if (variant === "List") {
            inner = [deserialize(inner[0])];
        }
        return DataType[variant](...inner);
    }
    DataType.deserialize = deserialize;
})(DataType || (exports.DataType = DataType = {}));
